<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>TypeScript | 孙文祥的博客</title><meta name="keywords" content="前端,TypeScript"><meta name="author" content="Sun wen xiang"><meta name="copyright" content="Sun wen xiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安装和介绍npm的–save 和 –save-dev区别  --save 表示应用在运行时依赖 --save-dev 表示应用只在开发目的依赖  全局安装编译器 npm install --global typescript  将ts文件编译成js文件 tsc xxx  会把ts自动生成对应文件名的js文件 还可以用高级的js语法，ts可以帮我们在低级的浏览器上适配  types：类型 新一代的特">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript">
<meta property="og:url" content="http://example.com/2022/07/21/TypeScript/index.html">
<meta property="og:site_name" content="孙文祥的博客">
<meta property="og:description" content="安装和介绍npm的–save 和 –save-dev区别  --save 表示应用在运行时依赖 --save-dev 表示应用只在开发目的依赖  全局安装编译器 npm install --global typescript  将ts文件编译成js文件 tsc xxx  会把ts自动生成对应文件名的js文件 还可以用高级的js语法，ts可以帮我们在低级的浏览器上适配  types：类型 新一代的特">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tu.sunning.fit/i/y/47.jpg">
<meta property="article:published_time" content="2022-07-21T00:43:02.000Z">
<meta property="article:modified_time" content="2022-07-21T00:43:02.000Z">
<meta property="article:author" content="Sun wen xiang">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tu.sunning.fit/i/y/47.jpg"><link rel="shortcut icon" href="/img/touxiang.png"><link rel="canonical" href="http://example.com/2022/07/21/TypeScript/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TypeScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-21 08:43:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tu.sunning.fit/i/y/47.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孙文祥的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TypeScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-21T00:43:02.000Z" title="更新于 2022-07-21 08:43:02">2022-07-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="TypeScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="安装和介绍"><a href="#安装和介绍" class="headerlink" title="安装和介绍"></a>安装和介绍</h1><p>npm的–save 和 –save-dev区别</p>
<ul>
<li><code>--save</code> 表示应用在运行时依赖</li>
<li><code>--save-dev</code> 表示应用只在开发目的依赖</li>
</ul>
<p>全局安装编译器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --global typescript</span><br></pre></td></tr></table></figure>

<p>将ts文件编译成js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc xxx</span><br></pre></td></tr></table></figure>

<p>会把ts自动生成对应文件名的js文件</p>
<p>还可以用高级的js语法，ts可以帮我们在低级的浏览器上适配</p>
<p><img src="https://tu.sunning.fit/i/2022/07/06/62c544ff0b97e.png" alt="image-20220601003156917"></p>
<p>types：类型</p>
<p>新一代的特性（在旧的版本上进行编译）</p>
<p>js没有的特性</p>
<p>先进的变成特性 meta-programming features</p>
<p>丰富的配置选项</p>
<p>先进的编译工具</p>
<p><img src="https://tu.sunning.fit/i/2022/07/06/62c54504611f7.png" alt="image-20220601004113735"></p>
<h1 id="Core-Types"><a href="#Core-Types" class="headerlink" title="Core Types"></a>Core Types</h1><p>js是动态类型，一个变量可能原来是数字，运行运行中变成字符串了，ts是静态类型，开发的时候就定义好了变量类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>1,5.3,-10</td>
<td>all numbers,no differentiation between integers or floats<br />（js里面所有number都默认是float类型）</td>
</tr>
<tr>
<td>string</td>
<td>‘hi’,(被&#96;包起来的模板字符串)hi</td>
<td>all text values</td>
</tr>
<tr>
<td>boolean</td>
<td>true ,false</td>
<td>just these two</td>
</tr>
<tr>
<td>object</td>
<td>{age:10}</td>
<td>any javascript object,more specific types(type of boject) are possible</td>
</tr>
<tr>
<td>Array</td>
<td>[1,2,3]</td>
<td>any javascript array,type can be flexible or strict（regarding the element types）</td>
</tr>
<tr>
<td>Tuple</td>
<td>[1,2]</td>
<td>added by typescript:fixed-length array</td>
</tr>
<tr>
<td>Enum</td>
<td>enum{NEW,OLD}</td>
<td>added by typescript:automatically enumeratedc global constant identifiers</td>
</tr>
<tr>
<td>any</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="number-string-boolean"><a href="#number-string-boolean" class="headerlink" title="number,string,boolean"></a>number,string,boolean</h2> <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1:<span class="built_in">number</span>,num2:<span class="built_in">number</span>,showResults:<span class="built_in">boolean</span>,phrase:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result=num1+num2</span><br><span class="line">    <span class="keyword">if</span>(showResults)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(phrase+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">5</span>;  <span class="comment">//ts识别是a只能是number类型，而且a是const,所以不能修改  类型：const number</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">2.8</span>;  <span class="comment">//类型:let number  会自动识别，所以没必要 let b:number=2.8</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>:<span class="built_in">number</span> </span><br><span class="line"><span class="keyword">const</span> c;</span><br><span class="line">c=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> d=<span class="string">&#x27;result is:&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(a,b,c,d));</span><br></pre></td></tr></table></figure>

<h2 id="boject"><a href="#boject" class="headerlink" title="boject"></a>boject</h2><p>原来定义好了的对象，不能增加删除里面的属性，不能更改属性的类型</p>
<p>定义一个object  （推荐）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span>=&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;sun&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>);  <span class="comment">//可以</span></span><br></pre></td></tr></table></figure>

<p>相当于这样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span>: <span class="built_in">object</span>=&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;sun&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">//不行，因为这个只告诉了是一个object,没告诉tsobject里面有什么东西 </span></span><br></pre></td></tr></table></figure>

<p>完整的写法（和上面的上面是一个作用）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span>: &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">   <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; =&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;sun&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>);  <span class="comment">//可以</span></span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>定义一个string类型的数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">favoriteActivities</span>:<span class="built_in">string</span>[];</span><br><span class="line">favoriteActivities=[<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>any类型的数组 和js数组一样存任意类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">favoriteActivities</span>:<span class="built_in">any</span>[];</span><br><span class="line">favoriteActivities=[<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p> 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 例如，可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>

<p>访问一个越界的元素，会使用联合类型替代</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>当需要使用的东西是固定的，可以给他们起不同的别名，这时候枚举的作用就显现出来了 一组值和它们的映射值</p>
<p>类似C#中的枚举类型，用枚举类型可以为一组数值赋予友好的名字</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>这样保证Color能表示的只有Red,Green,Blue （类似游戏角色的状态）</p>
<p>默认情况下从0开始元素编号，但是也可以手动指定成员的数值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;  <span class="comment">//这样就是 1,2,3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">3</span>, <span class="title class_">Green</span>=<span class="number">1</span>, <span class="title class_">Blue</span>=<span class="number">6</span>&#125;  <span class="comment">//这样就是3 1 6 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="string">&#x27;qwer&#x27;</span>, <span class="title class_">Green</span>=<span class="string">&#x27;dccde&#x27;</span>, <span class="title class_">Blue</span>=<span class="number">6</span>&#125;  <span class="comment">//这样就是qwer dccde 6 </span></span><br></pre></td></tr></table></figure>

<p>是代表的东西是什么，不是用对应的下标访问</p>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>any 指定的东西，之后可以进行修改  （就相当于是普通的js）作用就是让ts不检查这个的类型了</p>
<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>



<h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">input1</span>:<span class="built_in">number</span>|<span class="built_in">string</span>   <span class="comment">//代表可以是number类型或者是string类型</span></span><br></pre></td></tr></table></figure>



<p>但这样会带来变量不确定是什么类型，这时候一些操作需要确定类型后再操作</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combine</span>(<span class="params">input1:<span class="built_in">number</span>|<span class="built_in">string</span>,input2: <span class="built_in">number</span> | <span class="built_in">string</span> </span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> input1===<span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> input2===<span class="string">&quot;number&quot;</span>)&#123;</span><br><span class="line">    result =input1+input2;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result=input1.<span class="title function_">toString</span>()+input2.<span class="title function_">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Literal-Type"><a href="#Literal-Type" class="headerlink" title="Literal Type"></a>Literal Type</h2><blockquote>
<p>leteral 字面意义的，原文的</p>
</blockquote>
<p>把自己定义的 ‘值’ 当作 ‘类型’ 使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">gender</span>: <span class="title class_">Gender</span>;</span><br><span class="line">gender = <span class="string">&quot;male&quot;</span>; <span class="comment">// Correct</span></span><br><span class="line">gender = <span class="string">&quot;Chinese&quot;</span>; <span class="comment">// Error: not assignable</span></span><br></pre></td></tr></table></figure>

<p>在上面这个例子里面gender只能是male 或者 female</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Cat</span> = <span class="string">&quot;whiteCat&quot;</span> | <span class="string">&quot;blackCat&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = <span class="string">&quot;husky&quot;</span> | <span class="string">&quot;corgi&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pets</span> = <span class="title class_">Cat</span> | <span class="title class_">Dog</span>; </span><br><span class="line"><span class="comment">// The same as: type Pets = &quot;whiteCat&quot; | &quot;blackCat&quot; | &quot;husky&quot; | &quot;corgi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Falsy</span> = <span class="string">&quot;&quot;</span> | <span class="number">0</span> | <span class="literal">false</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 模拟JS的if条件判断规则</span></span><br></pre></td></tr></table></figure>

<h2 id="Type-Aliases-aliases-custom-types（自定义类型）"><a href="#Type-Aliases-aliases-custom-types（自定义类型）" class="headerlink" title="Type Aliases | aliases custom types（自定义类型）"></a>Type Aliases | aliases custom types（自定义类型）</h2><p>it’s common to want to use the same type more than once and refer to it by a single name.</p>
<p>自定义的类型可以是任何的东西</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Exactly the same as the earlier example</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>可以是basic type 也可是Literal type</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="number">1</span> | ‘<span class="number">123</span>’;</span><br></pre></td></tr></table></figure>

<h2 id="Function-Return-Types-amp-void"><a href="#Function-Return-Types-amp-void" class="headerlink" title="Function Return Types &amp; void"></a>Function Return Types &amp; void</h2><p>定义返回值的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFavoriteNumber</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不需要返回值 是void类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFavoriteNumber</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，如果要打印这个void类型的函数，返回值是undefined</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getFavoriteNumber);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>undefined:</strong></p>
<p>undefined在js中是一个确定的值，值本身就是未定义</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>):<span class="literal">undefined</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;  <span class="comment">//如果给函数定义一个undefined的返回值，一定要有return,而且return的东西是空的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Function-as-types"><a href="#Function-as-types" class="headerlink" title="Function as types"></a>Function as types</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">combineValues</span>:<span class="title class_">Function</span>; <span class="comment">//给combineValues定义function类型</span></span><br></pre></td></tr></table></figure>

<p>如果要指定函数的样子——箭头函数——还可以简写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">combineValues</span>:<span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<h1 id="Function-as-types-amp-Callback-回调"><a href="#Function-as-types-amp-Callback-回调" class="headerlink" title="Function as types&amp;Callback(回调)"></a>Function as types&amp;Callback(回调)</h1><p>定义了一个函数，函数体里面计算出result,然后在这个函数里面直接调用传入了的这个函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAndHandle</span>(<span class="params">n1:<span class="built_in">number</span>,n2:<span class="built_in">number</span>,cb:(num:<span class="built_in">number</span>)=&gt;<span class="built_in">void</span></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result=n1+n2;</span><br><span class="line">    <span class="title function_">cb</span>(result);</span><br><span class="line">&#125;<span class="comment">//如果这个传入的函数返回值是void,函数体有return也不会报错，只是外面的这个函数不会去处理返回的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">addAndHandle</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="unknown-type"><a href="#unknown-type" class="headerlink" title="unknown type"></a>unknown type</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">userInput</span>:<span class="built_in">unknown</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">userName</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">userInput=<span class="number">5</span>;</span><br><span class="line">userInput=<span class="string">&#x27;123&#x27;</span>;  <span class="comment">//可以赋值成任意类型，也可以类型转换</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> userInput===<span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    userName=userInput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unknown type和any的区别是一个是unknown是严格的类型，使用之前必须确认是什么类型才可以进行使用</p>
<h2 id="never-type"><a href="#never-type" class="headerlink" title="never type"></a>never type</h2><p>这个是告诉编译器什么也不返回，不返回任何值，包括undefined</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateError</span>(<span class="params">message:<span class="built_in">string</span>,code:<span class="built_in">number</span></span>):<span class="built_in">never</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>&#123;<span class="attr">message</span>:message,<span class="attr">code</span>:code&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">generateError</span>(<span class="string">&#x27;an error occurred&#x27;</span>,<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>像这样自己定义的异常抛出的就是never,但是ts的提示还是void（因为没啥影响，还没被ts改）</p>
<h1 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h1><p>有时候我们希望接口允许有任意的属性，ts给我们提供了两种索引签名字符串和数字</p>
<p>我们在自定义类型的时候，有可能会希望一个接口允许有任意的属性签名，这时候 <code>任意属性</code> 就派上用场了。</p>
<p>任意属性有两种定义的方式：一种属性签名是 <code>string</code> 类型的，另一种属性签名是 <code>number</code> 类型的。</p>
<h2 id="string类型任意属性"><a href="#string类型任意属性" class="headerlink" title="string类型任意属性"></a>string类型任意属性</h2><p>属性签名是string,比如对象的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: A = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>[prop: string]: number</code> 的意思是，<code>A</code> 类型的对象可以有任意属性签名，<code>string</code> 指的是对象的键都是字符串类型的，<code>number</code> 则是指定了属性值的类型。</p>
<p><code>prop</code> 类似于函数的形参，是可以取其他名字的。</p>
<h2 id="number类型任意属性"><a href="#number类型任意属性" class="headerlink" title="number类型任意属性"></a>number类型任意属性</h2><p>属性签名是数组类型的比如数组下标</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: B = [<span class="string">&#x27;suukii&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p><code>[index: number]: string</code> 的意思是，<code>B</code> 类型的数组可以有任意的数字下标，而且数组的成员的类型必须是 <code>string</code>。</p>
<p>同样的，<code>index</code> 也只是类似于函数形参的东西，用其他标识符也是完全可以的。</p>
<h2 id="同时定义两种属性"><a href="#同时定义两种属性" class="headerlink" title="同时定义两种属性"></a>同时定义两种属性</h2><p>一个接口可以同时定义这两种任意属性，但是 <code>number</code> 类型的签名指定的值类型必须是 <code>string</code> 类型的签名指定的值类型的子集</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;  <span class="comment">//这个是错的，index指定的类型是string,prop值的类型是number,string不是number的子集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Numeric index type &#x27;string&#x27; is not assignable to string index type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>换成下面这样就是可以的，因为function是object的子集</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">object</span>;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就像是 定义了一种东西，然后number类型就是可以在那一种东西里面在细分数组（只是类比，不一定对）</p>
</blockquote>
<h2 id="同时定义任意属性和其他类型的属性"><a href="#同时定义任意属性和其他类型的属性" class="headerlink" title="同时定义任意属性和其他类型的属性"></a>同时定义任意属性和其他类型的属性</h2><p><strong>一旦定义了任意属性，那么其他属性(确定属性、可选属性、只读属性等)的类型都必须是它的类型的子集</strong></p>
<p>比如想要一个Person接口，它有一个必选属性 <code>name</code> 和一个可选属性 <code>age</code>，另外还可以有其他 <code>string</code> 类型的任意属性签名。那么 <code>Person</code> 接口可能会被定义成这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>但其实这样子的定义是不成立的，因为 <code>[prop: string]: string</code> 的存在，规定了其他属性的类型也必须是 <code>string</code>，如果想要解决报错，我们可以使用联合类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>number</code> 类型的任意属性签名，情况也是一样的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArray</span> = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">string</span>;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Property &#x27;0&#x27; of type &#x27;string&#x27; is not assignable to numeric index type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>但是，<code>number</code> 类型的任意属性签名不会影响其他 <code>string</code> 类型的属性签名：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arg</span> = &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上，虽然指定了 <code>number</code> 类型的任意属性的类型是 <code>number</code>，但 <code>length</code> 属性是 <code>string</code> 类型的签名，所以不受前者的影响。</p>
<p>但是反过来就不一样了，如果接口定义了 <code>string</code> 类型的任意属性签名，它不仅会影响其他 <code>string</code> 类型的签名，也会影响其他 <code>number</code> 类型的签名。这一点可以参考<strong>两种任意类型签名并存时，<code>number</code> 类型的签名指定的值类型必须是 <code>string</code> 类型的签名指定的值类型的子集</strong>这句话。</p>
<h1 id="Compiler-amp-Configuration-Deep-Dive"><a href="#Compiler-amp-Configuration-Deep-Dive" class="headerlink" title="Compiler&amp;Configuration Deep Dive"></a>Compiler&amp;Configuration Deep Dive</h1><h2 id="手动配置live-server"><a href="#手动配置live-server" class="headerlink" title="手动配置live-server"></a>手动配置live-server</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>这时候会有package.json文件</p>
<p>用默认值一直回车</p>
<p>安装node的第三方库 lite-server</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev lite-server</span><br></pre></td></tr></table></figure>

<p>接着在package.json里面添加配置 start 和devDependencies</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;understanding-ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;app.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;lite-server&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Maximilian Schwarzmüller&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lite-server&quot;</span>: <span class="string">&quot;^2.5.4&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着使用</p>
<p>npm start 去启动这个脚本</p>
<h2 id="watch-model-amp-tsc-全局"><a href="#watch-model-amp-tsc-全局" class="headerlink" title="watch model &amp; tsc 全局"></a>watch model &amp; tsc 全局</h2><p>不用每次去编译同一个ts文件 ，开启watch model</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tsc xxx.ts --watch</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">tsc xxx.<span class="property">ts</span> -w</span><br></pre></td></tr></table></figure>



<p>监视一整个文件夹里面的内容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>这时候会出现一个配置文件： tsconfig.json</p>
<p>这时候再执行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">tsc</span><br></pre></td></tr></table></figure>

<p>就是编译所有存在的ts文件了</p>
<p>和watch mode一起使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">tsc --watch</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">tsc -w</span><br></pre></td></tr></table></figure>

<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    /* Visit https://aka.ms/tsconfig to <span class="built_in">read</span> more about this file */</span><br><span class="line"></span><br><span class="line">    /* Projects */</span><br><span class="line">    // <span class="string">&quot;incremental&quot;</span>: <span class="literal">true</span>,                              /* Save .tsbuildinfo files to allow <span class="keyword">for</span> incremental compilation of projects. */</span><br><span class="line">    // <span class="string">&quot;composite&quot;</span>: <span class="literal">true</span>,                                /* Enable constraints that allow a TypeScript project to be used with project references. */</span><br><span class="line">    // <span class="string">&quot;tsBuildInfoFile&quot;</span>: <span class="string">&quot;./.tsbuildinfo&quot;</span>,              /* Specify the path to .tsbuildinfo incremental compilation file. */</span><br><span class="line">    // <span class="string">&quot;disableSourceOfProjectReferenceRedirect&quot;</span>: <span class="literal">true</span>,  /* Disable preferring <span class="built_in">source</span> files instead of declaration files when referencing composite projects. */</span><br><span class="line">    // <span class="string">&quot;disableSolutionSearching&quot;</span>: <span class="literal">true</span>,                 /* Opt a project out of multi-project reference checking when editing. */</span><br><span class="line">    // <span class="string">&quot;disableReferencedProjectLoad&quot;</span>: <span class="literal">true</span>,             /* Reduce the number of projects loaded automatically by TypeScript. */</span><br><span class="line"></span><br><span class="line">    /* Language and Environment */</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es2016&quot;</span>,                                  /* Set the JavaScript language version <span class="keyword">for</span> emitted JavaScript and include compatible library declarations. */</span><br><span class="line">    // <span class="string">&quot;lib&quot;</span>: [],                                        /* Specify a <span class="built_in">set</span> of bundled library declaration files that describe the target runtime environment. */</span><br><span class="line">    // <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,                                /* Specify what JSX code is generated. */</span><br><span class="line">    // <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,                   /* Enable experimental support <span class="keyword">for</span> TC39 stage 2 draft decorators. */</span><br><span class="line">    // <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,                    /* Emit design-type metadata <span class="keyword">for</span> decorated declarations <span class="keyword">in</span> <span class="built_in">source</span> files. */</span><br><span class="line">    // <span class="string">&quot;jsxFactory&quot;</span>: <span class="string">&quot;&quot;</span>,                                 /* Specify the JSX factory <span class="keyword">function</span> used when targeting React JSX emit, e.g. <span class="string">&#x27;React.createElement&#x27;</span> or <span class="string">&#x27;h&#x27;</span>. */</span><br><span class="line">    // <span class="string">&quot;jsxFragmentFactory&quot;</span>: <span class="string">&quot;&quot;</span>,                         /* Specify the JSX Fragment reference used <span class="keyword">for</span> fragments when targeting React JSX emit e.g. <span class="string">&#x27;React.Fragment&#x27;</span> or <span class="string">&#x27;Fragment&#x27;</span>. */</span><br><span class="line">    // <span class="string">&quot;jsxImportSource&quot;</span>: <span class="string">&quot;&quot;</span>,                            /* Specify module specifier used to import the JSX factory <span class="built_in">functions</span> when using <span class="string">&#x27;jsx: react-jsx*&#x27;</span>. */</span><br><span class="line">    // <span class="string">&quot;reactNamespace&quot;</span>: <span class="string">&quot;&quot;</span>,                             /* Specify the object invoked <span class="keyword">for</span> <span class="string">&#x27;createElement&#x27;</span>. This only applies when targeting <span class="string">&#x27;react&#x27;</span> JSX emit. */</span><br><span class="line">    // <span class="string">&quot;noLib&quot;</span>: <span class="literal">true</span>,                                    /* Disable including any library files, including the default lib.d.ts. */</span><br><span class="line">    // <span class="string">&quot;useDefineForClassFields&quot;</span>: <span class="literal">true</span>,                  /* Emit ECMAScript-standard-compliant class fields. */</span><br><span class="line">    // <span class="string">&quot;moduleDetection&quot;</span>: <span class="string">&quot;auto&quot;</span>,                        /* Control what method is used to detect module-format JS files. */</span><br><span class="line"></span><br><span class="line">    /* Modules */</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,                                /* Specify what module code is generated. */</span><br><span class="line">    // <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                                  /* Specify the root folder within your <span class="built_in">source</span> files. */</span><br><span class="line">    // <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,                       /* Specify how TypeScript looks up a file from a given module specifier. */</span><br><span class="line">    // <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,                                  /* Specify the base directory to resolve non-relative module names. */</span><br><span class="line">    // <span class="string">&quot;paths&quot;</span>: &#123;&#125;,                                      /* Specify a <span class="built_in">set</span> of entries that re-map imports to additional lookup locations. */</span><br><span class="line">    // <span class="string">&quot;rootDirs&quot;</span>: [],                                   /* Allow multiple folders to be treated as one when resolving modules. */</span><br><span class="line">    // <span class="string">&quot;typeRoots&quot;</span>: [],                                  /* Specify multiple folders that act like <span class="string">&#x27;./node_modules/@types&#x27;</span>. */</span><br><span class="line">    // <span class="string">&quot;types&quot;</span>: [],                                      /* Specify <span class="built_in">type</span> package names to be included without being referenced <span class="keyword">in</span> a <span class="built_in">source</span> file. */</span><br><span class="line">    // <span class="string">&quot;allowUmdGlobalAccess&quot;</span>: <span class="literal">true</span>,                     /* Allow accessing UMD globals from modules. */</span><br><span class="line">    // <span class="string">&quot;moduleSuffixes&quot;</span>: [],                             /* List of file name suffixes to search when resolving a module. */</span><br><span class="line">    // <span class="string">&quot;resolveJsonModule&quot;</span>: <span class="literal">true</span>,                        /* Enable importing .json files. */</span><br><span class="line">    // <span class="string">&quot;noResolve&quot;</span>: <span class="literal">true</span>,                                /* Disallow <span class="string">&#x27;import&#x27;</span>s, <span class="string">&#x27;require&#x27;</span>s or <span class="string">&#x27;&lt;reference&gt;&#x27;</span>s from expanding the number of files TypeScript should add to a project. */</span><br><span class="line"></span><br><span class="line">    /* JavaScript Support */</span><br><span class="line">    // <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                                  /* Allow JavaScript files to be a part of your program. Use the <span class="string">&#x27;checkJS&#x27;</span> option to get errors from these files. */</span><br><span class="line">    // <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                                  /* Enable error reporting <span class="keyword">in</span> type-checked JavaScript files. */</span><br><span class="line">    // <span class="string">&quot;maxNodeModuleJsDepth&quot;</span>: 1,                        /* Specify the maximum folder depth used <span class="keyword">for</span> checking JavaScript files from <span class="string">&#x27;node_modules&#x27;</span>. Only applicable with <span class="string">&#x27;allowJs&#x27;</span>. */</span><br><span class="line"></span><br><span class="line">    /* Emit */</span><br><span class="line">    // <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,                              /* Generate .d.ts files from TypeScript and JavaScript files <span class="keyword">in</span> your project. */</span><br><span class="line">    // <span class="string">&quot;declarationMap&quot;</span>: <span class="literal">true</span>,                           /* Create sourcemaps <span class="keyword">for</span> d.ts files. */</span><br><span class="line">    // <span class="string">&quot;emitDeclarationOnly&quot;</span>: <span class="literal">true</span>,                      /* Only output d.ts files and not JavaScript files. */</span><br><span class="line">    // <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,                                /* Create <span class="built_in">source</span> map files <span class="keyword">for</span> emitted JavaScript files. */</span><br><span class="line">    // <span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>,                                  /* Specify a file that bundles all outputs into one JavaScript file. If <span class="string">&#x27;declaration&#x27;</span> is <span class="literal">true</span>, also designates a file that bundles all .d.ts output. */</span><br><span class="line">    // <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                                   /* Specify an output folder <span class="keyword">for</span> all emitted files. */</span><br><span class="line">    // <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                           /* Disable emitting comments. */</span><br><span class="line">    // <span class="string">&quot;noEmit&quot;</span>: <span class="literal">true</span>,                                   /* Disable emitting files from a compilation. */</span><br><span class="line">    // <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,                            /* Allow importing helper <span class="built_in">functions</span> from tslib once per project, instead of including them per-file. */</span><br><span class="line">    // <span class="string">&quot;importsNotUsedAsValues&quot;</span>: <span class="string">&quot;remove&quot;</span>,               /* Specify emit/checking behavior <span class="keyword">for</span> imports that are only used <span class="keyword">for</span> types. */</span><br><span class="line">    // <span class="string">&quot;downlevelIteration&quot;</span>: <span class="literal">true</span>,                       /* Emit more compliant, but verbose and less performant JavaScript <span class="keyword">for</span> iteration. */</span><br><span class="line">    // <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;&quot;</span>,                                 /* Specify the root path <span class="keyword">for</span> debuggers to find the reference <span class="built_in">source</span> code. */</span><br><span class="line">    // <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;&quot;</span>,                                    /* Specify the location <span class="built_in">where</span> debugger should locate map files instead of generated locations. */</span><br><span class="line">    // <span class="string">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>,                          /* Include sourcemap files inside the emitted JavaScript. */</span><br><span class="line">    // <span class="string">&quot;inlineSources&quot;</span>: <span class="literal">true</span>,                            /* Include <span class="built_in">source</span> code <span class="keyword">in</span> the sourcemaps inside the emitted JavaScript. */</span><br><span class="line">    // <span class="string">&quot;emitBOM&quot;</span>: <span class="literal">true</span>,                                  /* Emit a UTF-8 Byte Order Mark (BOM) <span class="keyword">in</span> the beginning of output files. */</span><br><span class="line">    // <span class="string">&quot;newLine&quot;</span>: <span class="string">&quot;crlf&quot;</span>,                                /* Set the newline character <span class="keyword">for</span> emitting files. */</span><br><span class="line">    // <span class="string">&quot;stripInternal&quot;</span>: <span class="literal">true</span>,                            /* Disable emitting declarations that have <span class="string">&#x27;@internal&#x27;</span> <span class="keyword">in</span> their JSDoc comments. */</span><br><span class="line">    // <span class="string">&quot;noEmitHelpers&quot;</span>: <span class="literal">true</span>,                            /* Disable generating custom helper <span class="built_in">functions</span> like <span class="string">&#x27;__extends&#x27;</span> <span class="keyword">in</span> compiled output. */</span><br><span class="line">    // <span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">true</span>,                            /* Disable emitting files <span class="keyword">if</span> any <span class="built_in">type</span> checking errors are reported. */</span><br><span class="line">    // <span class="string">&quot;preserveConstEnums&quot;</span>: <span class="literal">true</span>,                       /* Disable erasing <span class="string">&#x27;const enum&#x27;</span> declarations <span class="keyword">in</span> generated code. */</span><br><span class="line">    // <span class="string">&quot;declarationDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                           /* Specify the output directory <span class="keyword">for</span> generated declaration files. */</span><br><span class="line">    // <span class="string">&quot;preserveValueImports&quot;</span>: <span class="literal">true</span>,                     /* Preserve unused imported values <span class="keyword">in</span> the JavaScript output that would otherwise be removed. */</span><br><span class="line"></span><br><span class="line">    /* Interop Constraints */</span><br><span class="line">    // <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,                          /* Ensure that each file can be safely transpiled without relying on other imports. */</span><br><span class="line">    // <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,             /* Allow <span class="string">&#x27;import x from y&#x27;</span> when a module doesn<span class="string">&#x27;t have a default export. */</span></span><br><span class="line"><span class="string">    &quot;esModuleInterop&quot;: true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables &#x27;</span>allowSyntheticDefaultImports<span class="string">&#x27; for type compatibility. */</span></span><br><span class="line"><span class="string">    // &quot;preserveSymlinks&quot;: true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */</span></span><br><span class="line"><span class="string">    &quot;forceConsistentCasingInFileNames&quot;: true,            /* Ensure that casing is correct in imports. */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Type Checking */</span></span><br><span class="line"><span class="string">    &quot;strict&quot;: true,                                      /* Enable all strict type-checking options. */</span></span><br><span class="line"><span class="string">    // &quot;noImplicitAny&quot;: true,                            /* Enable error reporting for expressions and declarations with an implied &#x27;</span>any<span class="string">&#x27; type. */</span></span><br><span class="line"><span class="string">    // &quot;strictNullChecks&quot;: true,                         /* When type checking, take into account &#x27;</span>null<span class="string">&#x27; and &#x27;</span>undefined<span class="string">&#x27;. */</span></span><br><span class="line"><span class="string">    // &quot;strictFunctionTypes&quot;: true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */</span></span><br><span class="line"><span class="string">    // &quot;strictBindCallApply&quot;: true,                      /* Check that the arguments for &#x27;</span><span class="built_in">bind</span><span class="string">&#x27;, &#x27;</span>call<span class="string">&#x27;, and &#x27;</span>apply<span class="string">&#x27; methods match the original function. */</span></span><br><span class="line"><span class="string">    // &quot;strictPropertyInitialization&quot;: true,             /* Check for class properties that are declared but not set in the constructor. */</span></span><br><span class="line"><span class="string">    // &quot;noImplicitThis&quot;: true,                           /* Enable error reporting when &#x27;</span>this<span class="string">&#x27; is given the type &#x27;</span>any<span class="string">&#x27;. */</span></span><br><span class="line"><span class="string">    // &quot;useUnknownInCatchVariables&quot;: true,               /* Default catch clause variables as &#x27;</span>unknown<span class="string">&#x27; instead of &#x27;</span>any<span class="string">&#x27;. */</span></span><br><span class="line"><span class="string">    // &quot;alwaysStrict&quot;: true,                             /* Ensure &#x27;</span>use strict<span class="string">&#x27; is always emitted. */</span></span><br><span class="line"><span class="string">    // &quot;noUnusedLocals&quot;: true,                           /* Enable error reporting when local variables aren&#x27;</span>t <span class="built_in">read</span>. */</span><br><span class="line">    // <span class="string">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>,                       /* Raise an error when a <span class="keyword">function</span> parameter isn<span class="string">&#x27;t read. */</span></span><br><span class="line"><span class="string">    // &quot;exactOptionalPropertyTypes&quot;: true,               /* Interpret optional property types as written, rather than adding &#x27;</span>undefined<span class="string">&#x27;. */</span></span><br><span class="line"><span class="string">    // &quot;noImplicitReturns&quot;: true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */</span></span><br><span class="line"><span class="string">    // &quot;noFallthroughCasesInSwitch&quot;: true,               /* Enable error reporting for fallthrough cases in switch statements. */</span></span><br><span class="line"><span class="string">    // &quot;noUncheckedIndexedAccess&quot;: true,                 /* Add &#x27;</span>undefined<span class="string">&#x27; to a type when accessed using an index. */</span></span><br><span class="line"><span class="string">    // &quot;noImplicitOverride&quot;: true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */</span></span><br><span class="line"><span class="string">    // &quot;noPropertyAccessFromIndexSignature&quot;: true,       /* Enforces using indexed accessors for keys declared using an indexed type. */</span></span><br><span class="line"><span class="string">    // &quot;allowUnusedLabels&quot;: true,                        /* Disable error reporting for unused labels. */</span></span><br><span class="line"><span class="string">    // &quot;allowUnreachableCode&quot;: true,                     /* Disable error reporting for unreachable code. */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Completeness */</span></span><br><span class="line"><span class="string">    // &quot;skipDefaultLibCheck&quot;: true,                      /* Skip type checking .d.ts files that are included with TypeScript. */</span></span><br><span class="line"><span class="string">    &quot;skipLibCheck&quot;: true                                 /* Skip type checking all .d.ts files. */</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="exclude配置项"><a href="#exclude配置项" class="headerlink" title="exclude配置项"></a>exclude配置项</h3><p>排除哪些文件</p>
<p>要用双引号包裹，不能用单引号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    /* Visit https://aka.ms/tsconfig to <span class="built_in">read</span> more about this file */</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    /* Completeness */</span><br><span class="line">    // <span class="string">&quot;skipDefaultLibCheck&quot;</span>: <span class="literal">true</span>,                      /* Skip <span class="built_in">type</span> checking .d.ts files that are included with TypeScript. */</span><br><span class="line">    <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>                                 /* Skip <span class="built_in">type</span> checking all .d.ts files. */</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //这里添加exclude配置项 </span><br><span class="line">  “exclude”:[</span><br><span class="line">  	“analytics.ts” </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以用通配符</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;*.dev.ts&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;**/*.dev.ts&quot;</span></span><br></pre></td></tr></table></figure>

<p>代表所有符合这种格式的都排除</p>
<p>exclude默认排除”node_modules“ 配置项里面就不用写了</p>
<h3 id="include配置"><a href="#include配置" class="headerlink" title="include配置"></a>include配置</h3><p>如果设置了include类型，则在include以外的所有东西ts都不会进行操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;include&quot;</span>:[</span><br><span class="line">	<span class="string">&quot;app.ts&quot;</span>  </span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="files配置"><a href="#files配置" class="headerlink" title="files配置"></a>files配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;files&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;core.ts&quot;</span>,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>



<p><code>&quot;files&quot;</code>指定一个<strong>包含相对或绝对文件路径的列表</strong>。 <code>&quot;include&quot;</code>和<code>&quot;exclude&quot;</code>属性指定一个文件glob匹配模式列表。 支持的glob通配符有：</p>
<ul>
<li><code>*</code> 匹配0或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
<p>如果<code>&quot;files&quot;</code>和<code>&quot;include&quot;</code>都没有被指定，编译器默认包含当前目录和子目录下所有的TypeScript文件（<code>.ts</code>, <code>.d.ts</code> 和 <code>.tsx</code>），排除在<code>&quot;exclude&quot;</code>里指定的文件。JS文件（<code>.js</code>和<code>.jsx</code>）也被包含进来如果<code>allowJs</code>被设置成<code>true</code>。 如果指定了 <code>&quot;files&quot;</code>或<code>&quot;include&quot;</code>，编译器会将它们结合一并包含进来。 使用 <code>&quot;outDir&quot;</code>指定的目录下的文件永远会被编译器排除，除非你明确地使用<code>&quot;files&quot;</code>将其包含进来（这时就算用<code>exclude</code>指定也没用）。</p>
<p><strong>target</strong></p>
<p>编译完成后的目标js版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;target&quot;</span>: <span class="string">&quot;es2016&quot;</span>,                                 </span><br></pre></td></tr></table></figure>



<p><strong>lib</strong></p>
<p>如果不设置lib,则默认适配target指定的那个东西需要的库</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;lib&quot;</span>: [], </span><br></pre></td></tr></table></figure>

<p>lib的作用在于写代码的时候，document,map之类的是可以全局使用的，这个就是因为引入了对应的lib库</p>
<p><strong>allowJs</strong> <strong>checkJs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &quot;allowJs&quot;: true,                                  /* Allow JavaScript files to be a part of your program. Use the &#x27;checkJS&#x27; option to get errors from these files. */</span><br><span class="line">// &quot;checkJs&quot;: true,                                  /* Enable error reporting in type-checked JavaScript files. */</span><br></pre></td></tr></table></figure>

<p>ts编译器也会对js执行监视，代码检查等等</p>
<p><strong>sourceMap</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure>

<p>会生成xxx.js.map  chrome 代码检查工具看source这时候就可以识别到ts文件了</p>
<p>这时候甚至可以在代码检查工具里面设置断点</p>
<p><strong>outDir rootDir</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>,  需要管理的ts文件在哪个位置</span><br><span class="line"><span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>,   ts导出的js文件在哪个位置</span><br></pre></td></tr></table></figure>



<p><strong>removeComments</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure>

<p>如果ts有注释，js文件会把标的注释去掉</p>
<p><strong>noEmit</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;noEmit&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>不生成js文件，ts只进行检查的工作</p>
<p><strong>downlevelIteration</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;downlevelIteration&quot;</span>: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure>

<p>如果编译的js版本比较低，而且有4,5个循环的时候，打开这个可以提供更好的支持</p>
<p><strong>noEmitOnError</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>

<p>即使ts文件有错误仍然可以生成js文件，配置项默认就是false</p>
<p><strong>strict</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure>

<p>严格模式，进行所有的类型检查</p>
<p><strong>noImplicitAny</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>没有隐含的any属性</p>
<p><strong>strictNullChecks</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>是否为非空的检查</p>
<p><strong>noImplicitReturns</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure>

<p>不允许默认的return,这时候每个函数就算不返回值，也要写一个return</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addd</span>(<span class="params">n1:<span class="built_in">number</span>,n2:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n1+n2)&#123;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>strictBindCallApply</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;strictBindCallApply&quot;</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>检测有没有绑定到对应物体身上，默认是true，不能绑定null</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(button)&#123;</span><br><span class="line">    button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="title function_">clickHandler</span>(<span class="string">&#x27;123&#x27;</span>).<span class="title function_">bind</span>(<span class="literal">null</span>)); <span class="comment">//如果绑在了null上面就错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>bind</strong></p>
<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，</p>
<p>这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，</p>
<p>而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="variable language_">module</span>.<span class="property">getX</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unboundGetX</span>()); <span class="comment">// The function gets invoked at the global scope</span></span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.<span class="title function_">bind</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">boundGetX</span>());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<p>返回一个原函数的拷贝，并拥有指定的 <strong><code>this</code></strong> 值和初始参数。</p>
<p><strong>用法</strong></p>
<p><strong>创建绑定函数</strong></p>
<p>最简单的用法是创建一个函数，不论怎么调用，这个函数都有<strong>同样</strong>的 <strong><code>this</code></strong> 值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">JavaScript 新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">9</span>;    <span class="comment">// 在浏览器中，this 指向全局的 &quot;window&quot; 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">81</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">getX</span>(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="variable language_">module</span>.<span class="property">getX</span>;</span><br><span class="line"><span class="title function_">retrieveX</span>();</span><br><span class="line"><span class="comment">// 返回 9 - 因为函数是在全局作用域中调用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，把 &#x27;this&#x27; 绑定到 module 对象</span></span><br><span class="line"><span class="comment">// 新手可能会将全局变量 x 与 module 的属性 x 混淆</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.<span class="title function_">bind</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="title function_">boundGetX</span>(); <span class="comment">// 81</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>偏函数</strong></p>
<p><code>bind()</code> 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 <code>bind()</code> 的参数写在 <code>this</code> 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">list</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addArguments</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = <span class="title function_">list</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="title function_">addArguments</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> addThirtySeven = addArguments.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="title function_">leadingThirtysevenList</span>();</span><br><span class="line"><span class="comment">// [37]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3 = <span class="title function_">leadingThirtysevenList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [37, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">addThirtySeven</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 37 + 5 = 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = <span class="title function_">addThirtySeven</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>配合setTimeout</strong></p>
<p>在默认情况下，使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>window.setTimeout()</code></a> 时，<code>this</code> 关键字会指向 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>window</code></a>（或 <code>global</code>）对象。当类的方法中需要 <code>this</code> 指向类的实例时，你可能需要显式地把 <code>this</code> 绑定到回调函数，就不会丢失该实例的引用。</p>
</blockquote>
<h1 id="Anvance-JavaScript"><a href="#Anvance-JavaScript" class="headerlink" title="Anvance JavaScript"></a>Anvance JavaScript</h1><h2 id="设置默认的函数值"><a href="#设置默认的函数值" class="headerlink" title="设置默认的函数值"></a>设置默认的函数值</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">xxx</span>:<span class="function">(<span class="params">a:<span class="built_in">number</span>|<span class="built_in">number</span>,b:<span class="built_in">number</span>=<span class="number">1</span></span>)=&gt;</span><span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>这样如果调用的时候不输入b默认的值就是1，但是有默认值的函数只能是在后面的，因为如果写在前面，函数处理的时候不知道输入的值是不是用传入的值还是默认的值</p>
<h2 id="对象-x3D-对象-vs-对象-x3D-…对象"><a href="#对象-x3D-对象-vs-对象-x3D-…对象" class="headerlink" title="对象&#x3D;对象 vs 对象&#x3D;{…对象}"></a>对象&#x3D;对象 vs 对象&#x3D;{…对象}</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Max&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> copiedPerson=person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copiedPerson=&#123;...person&#125;</span><br></pre></td></tr></table></figure>

<p>上面第一个的做法是copiedPerson的指针指向了person,如果对copiedPerson进行操作也是对person进行的操作</p>
<p>第二个的做法是把person的键值拆开来给copiedPerson,是完全创建一个新的</p>
<h2 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add=(...<span class="attr">number</span>:<span class="built_in">number</span>[])&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">number</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">curResult,curValue</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curResult+curValue;</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不确定输入的个数有多少个的时候,用…number代表传入的数据的个数</p>
<p>数组.reduce 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">number.<span class="title function_">reduce</span>(<span class="function">(<span class="params">curResult,curValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curResult+curValue;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>表示从0开始计数，curResult是每次持续的值，curValue相当于是遍历的每一个值</p>
<p>如果指定只能要3个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add=(...number:number[number,number,number])&#123;</span><br><span class="line">    return number.reduce((curResult,curValue)=&gt;&#123;</span><br><span class="line">        return curResult+curValue;</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array-amp-Object-Destructuring"><a href="#Array-amp-Object-Destructuring" class="headerlink" title="Array &amp; Object Destructuring"></a>Array &amp; Object Destructuring</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hobbies=[<span class="string">&#x27;eat&#x27;</span>,<span class="string">&#x27;sleep&#x27;</span>,<span class="string">&#x27;eateat&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [hobby1,hobby2,...remainingHobbies]=hobbies;</span><br><span class="line"><span class="comment">//hobby1代表hobbies的第一个元素，hobby2代表hobbies的第二个元素，...remainingHobbies是一个数组，代表剩下的所有的元素</span></span><br><span class="line"><span class="comment">//这个操作是不会对原来的数组产生影响的</span></span><br><span class="line"><span class="keyword">const</span> person=&#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&#x27;sun&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;firstName,age&#125;=person</span><br><span class="line"><span class="comment">//firstName,age必须和person中的变量一致，因为对象里面不是一个有序数组，如果想要起别名，可以</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">firstName</span>:myName,age&#125;=person</span><br><span class="line">这样，person中的firstName,就等于变量myName了</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName);   <span class="comment">//sun</span></span><br></pre></td></tr></table></figure>



<p>上面这些都是es6本身就有的，和ts没关系，但是，如果在ts的配置文件里面把target改成es5,ts生成的js就会用另外的语法来完成上面的东西</p>
<h1 id="Class-amp-Interfaces"><a href="#Class-amp-Interfaces" class="headerlink" title="Class &amp; Interfaces"></a>Class &amp; Interfaces</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;   <span class="comment">//规定类型</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xxx=<span class="keyword">new</span> <span class="title class_">Deaparment</span>(<span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>constructor 是构造方法，当创建这个类的时候调用</p>
<p>顺便看一下在ts翻译成js成es5版本的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Department</span>=(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Deaprtment</span>(<span class="params">n</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Deaprtment</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>立即执行函数</p>
<p>通常有两种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">   ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>表示执行到这里的时候立刻调用这个函数</p>
</blockquote>
<p>对上面的例子添加一个函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;   <span class="comment">//规定类型</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">describe</span>(<span class="params"><span class="variable language_">this</span>:Department</span>)&#123;  <span class="comment">//这个this是对调用describe的对象做出的限定，那个对象里面必须包含department类用到了的东西（这里是this.name）</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department&#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>);   <span class="comment">//需要有this否则指全局的name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～</span><br><span class="line"><span class="keyword">const</span> accoutingCopy=&#123;<span class="attr">describe</span>:accounting.<span class="property">describe</span>&#125; </span><br><span class="line">accountingCopy.<span class="title function_">describe</span>();  <span class="comment">//错误，因为调用describe的不是department对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～</span><br><span class="line"><span class="keyword">const</span> accoutingCopy=&#123;<span class="attr">name</span>:<span class="string">&#x27;一个部门&#x27;</span>,<span class="attr">describe</span>:accounting.<span class="property">describe</span>&#125; </span><br><span class="line">accountingCopy.<span class="title function_">describe</span>(); <span class="comment">//这时候可以进行调用，因为这时候this指的是Department了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在需要public的对象上面可以加上public 修饰符</p>
<p>关于类的构造的更简单的声明方式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    <span class="comment">//private id:string;</span></span><br><span class="line">    <span class="comment">//private name:string;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">employees</span>:<span class="built_in">string</span>[]=[];</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> id:<span class="built_in">string</span>,<span class="keyword">public</span> name:<span class="built_in">string</span></span>)&#123;  <span class="comment">//这里一句顶地上这里注释掉的这四句话</span></span><br><span class="line">        <span class="comment">//this.id=id;</span></span><br><span class="line">        <span class="comment">//this.name=name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>readonly 赋值之后就不能更改了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> isReadonly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance (继承)"></a>Inheritance (继承)</h2><blockquote>
<p>interface  界面(尤指屏幕布局和菜单);接口;接口程序;</p>
<p>Inheritance 继承物，遗产</p>
</blockquote>
<p>这个是继承不是接口啊，只是英语和接口的声明语句太像了</p>
<p>继承会从父类上面继承到所有的东西</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对继承的对象扩展"><a href="#对继承的对象扩展" class="headerlink" title="对继承的对象扩展"></a>对继承的对象扩展</h3><p>在使用this之前一定要先使用super</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IDDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">admins</span>:<span class="built_in">string</span>[]</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id:<span class="built_in">string</span>,admins:<span class="built_in">string</span>[]</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(id,<span class="string">&#x27;IT&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">admins</span>=admins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单写法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IDDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id:<span class="built_in">string</span>,<span class="keyword">public</span> admins:<span class="built_in">string</span>[]</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(id,<span class="string">&#x27;IT&#x27;</span>);<span class="comment">//这个相当于用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> accounting=<span class="keyword">new</span> <span class="title class_">ITDepartment</span>(<span class="string">&#x27;d1&#x27;</span>,[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]);</span><br></pre></td></tr></table></figure>



<h2 id="Getters-amp-Setters"><a href="#Getters-amp-Setters" class="headerlink" title="Getters &amp; Setters"></a>Getters &amp; Setters</h2><p>getter setter are property where you execute a function or a method when you retrieve（检索） a value</p>
<p>getters 是在读取的时候进行调用</p>
<p>定义的时候get要写成一个方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">mygetter</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">xxx</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> xxx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;xxxx&#x27;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这本质是一个属性，使用的时候就像是读属性一样用就行了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">xxx.<span class="property">mygetter</span>;</span><br></pre></td></tr></table></figure>



<p>setters 是在改变的时候调用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title function_">mysetter</span>(<span class="params">input:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!input)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Please pass in a valid value&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addReport</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时候</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">xxx.<span class="property">mysetter</span>=xxxx</span><br></pre></td></tr></table></figure>



<h2 id="Static-properties-and-methods"><a href="#Static-properties-and-methods" class="headerlink" title="Static properties and methods"></a>Static properties and methods</h2><p>静态属性，静态方法</p>
<p>如果想要不通过实例化对象，就可以使用对象里面定义的方法或者属性，这时候就可以用静态属性&#x2F;方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">static</span> fiscalYear=<span class="number">2020</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">createEmployee</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要访问静态属性&#x2F;方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Department</span>.<span class="title function_">createEmployee</span>(<span class="string">&#x27;IT部门&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Department</span>.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>



<p>在有静态属性的类里面访问这个静态属性，和在外面用的访问方法一样 类名.属性名</p>
<p>不能用this.xxx来访问</p>
<h2 id="Override-and-Abstract"><a href="#Override-and-Abstract" class="headerlink" title="Override and Abstract"></a>Override and Abstract</h2><p>重写和抽象类</p>
<p>想要重写直接在被继承的类里面写上一个同名的方法即可</p>
<p>但是如果父类里面需要所有的子类都要重新实现一个方法，就要用到abstract方法了</p>
<ul>
<li>方法前加上abstract声明,方法只保留方法声明，去掉方法实现</li>
<li>在类前面加上abstract声明——这样这个类就不能自己实例化了</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="title function_">describe</span>(<span class="attr">this</span>:<span class="title class_">Department</span>):<span class="built_in">void</span></span><br></pre></td></tr></table></figure>



<h2 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h2><p>单例设计模式</p>
<p>现在类里面声明一个</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">lastReport</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>:<span class="title class_">AccountingDepartment</span>;<span class="comment">// 一个私有的单例，存的就是这个对象本身</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params">id:<span class="built_in">string</span>,<span class="keyword">private</span> reports:<span class="built_in">string</span>[]</span>)&#123;  <span class="comment">//private reports:string[] 是简写形式，相当于在这个类里面定义一个reports，传入的值就是reports</span></span><br><span class="line">        <span class="variable language_">super</span>(id,<span class="string">&#x27;Accounting&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastReport</span>=reports[<span class="number">0</span>];  </span><br><span class="line">    &#125; <span class="comment">//构造方法变成私有的作用是为了在外面不能通过new xxx来创建一个新的实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">instance</span>)&#123;  <span class="comment">//虽然是使用static的东西，需要类.属性，但是在同一个类的static方法里面，可以直接使用this进行访问</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">instance</span>=<span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要使用这个单例就</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">AccountingDepartment</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>

<p>所有得到的都是同一个AccountingDepartment单例</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labelledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj);</span><br></pre></td></tr></table></figure>

<p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabelledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labelledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj);</span><br></pre></td></tr></table></figure>

<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<h3 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h3><p>接口的首字母一般大写，不是必须，但是是约定写法</p>
<p>接口可以让我们提前定义好一个类的类型和规范是什么样子，还可以给其他类继承，使多个类都能继承自同一个接口，使用同一个规范</p>
<p>定义一个接口，并按照这个接口实例化一个对象</p>
<p>如果用这种写法的话，user1不能再添加其他的方法或者属性了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;    <span class="comment">//对于目前的实现来说  变成 type Person=&#123;......&#125; 是没有区别的</span></span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>=<span class="string">&#x27;max&#x27;</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">greet</span>(<span class="attr">phrase</span>:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">user1</span>:<span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line">user1=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Max&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">30</span>,</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params">phrase:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(phrase+<span class="string">&#x27; &#x27;</span>+<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>interface 和 type的区别</p>
<table>
<thead>
<tr>
<th>interface</th>
<th>type</th>
</tr>
</thead>
<tbody><tr>
<td>只能对类进行格式上的限制</td>
<td>不止对类做限制</td>
</tr>
<tr>
<td>一个对象可以继承多个接口，但是只能继承一个类</td>
<td></td>
</tr>
</tbody></table>
<p>和类的区别是只有接口只有声明，没有实现，而且对象可以继承多个接口</p>
<p>继承自接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Greetable</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了接口的对象还可以添加更多的方法或者属性</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> xx&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span> <span class="keyword">implements</span> xx&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">user1</span>:xx    <span class="comment">//这种是可以的，因为xxx本身就是实现了接口的对象</span></span><br><span class="line">user1=<span class="keyword">new</span> <span class="title function_">xxx</span>();</span><br></pre></td></tr></table></figure>



<p><strong>readonly:</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> xx&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>:<span class="built_in">string</span>;    <span class="comment">//接口里面对变量的设置只能是readonly,不能public,private之类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span> <span class="keyword">implements</span> xx&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;   <span class="comment">//虽然没写readonly，但是因为实现了接口，所以也默认是readonly了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口可以继承接口，类也可以多重继承接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test1&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> test2 <span class="keyword">extends</span> test1,test3&#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="attr">phrase</span>:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> iimplements test2&#123;  <span class="comment">//就要把test2定义的所有要求，以及test2继承的两个接口都实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口也可以组成一个type</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test1&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> test2 <span class="keyword">extends</span> test1,test3&#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="attr">phrase</span>:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span>=test1|test2</span><br></pre></td></tr></table></figure>





<p>接口也能和type类型一样规定一个函数的样式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type AddFn=(a:number,b:number)=&gt;number;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AddFn</span>&#123;   <span class="comment">//接口里面直接写函数的配置，但是不像函数一样由 =&gt; 而是 :</span></span><br><span class="line">    (<span class="attr">a</span>:<span class="built_in">number</span>,<span class="attr">b</span>:<span class="built_in">number</span>):<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>:<span class="title class_">AddFn</span>;</span><br><span class="line">add=<span class="function">(<span class="params">n1:<span class="built_in">number</span>,n2:<span class="built_in">number</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>optional properties</strong></p>
<p>如果想要一个属性可以存在也可以不存在,在这个变量的后面加一个？即可 </p>
<p>所有声明变量的地方都可以，不只是接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> xxx&#123;</span><br><span class="line">    xx?:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxxx</span> <span class="keyword">implements</span> xxx&#123;</span><br><span class="line">    xxxxxx?:<span class="built_in">string</span>;</span><br><span class="line">    greet?():<span class="built_in">void</span>;  <span class="comment">//可选的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ts 转换的时候怎么处理接口：</p>
<p>接口不会体现到js里面，接口只是ts用来规范代码用的</p>
<h2 id="Advanced-Types-amp-TypeScript-Features"><a href="#Advanced-Types-amp-TypeScript-Features" class="headerlink" title="Advanced Types &amp; TypeScript Features"></a>Advanced Types &amp; TypeScript Features</h2><h3 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h3><p>组合类型 allows us to combine other types</p>
<p>相同的功能也可以通过接口来实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Admin</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">privileges</span>:<span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">startDate</span>:<span class="title class_">Date</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElevatedEmployee</span>=<span class="title class_">Admin</span>&amp;<span class="title class_">Employee</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">e1</span>:<span class="title class_">ElevatedEmployee</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Max&#x27;</span>,</span><br><span class="line">    <span class="attr">privileges</span>:[<span class="string">&#x27;create-server&#x27;</span>],</span><br><span class="line">    <span class="attr">startDate</span>:<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如果组合类型被用来组合联合类型，则组合类型是联合类型的交集</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> e1=<span class="built_in">string</span> | int;</span><br><span class="line"><span class="keyword">type</span> e2=<span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> e3=e1&amp;e2;  <span class="comment">//这时候e3的类型是string</span></span><br></pre></td></tr></table></figure>



<h2 id="Type-Guards"><a href="#Type-Guards" class="headerlink" title="Type Guards"></a>Type Guards</h2><p>type guards is just a term（描述） that describes the idea or approach  checking if a certain property or method exists before you try to use it</p>
<p>判断一个变量是不是常规的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>判断属性在没在类里面</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp)</span><br></pre></td></tr></table></figure>

<p>判断这个类是什么类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> <span class="title class_">Truck</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么不用 <code>typeof vehicle ===&#39;Truck&#39;</code>，因为这个是放到js里面判断的，js不认识Truck这个自己定义的类</p>
<p>instanceof 是js里面的方法，Truck ts认识，顺着Truck构造方法变成js认识的东西</p>
</blockquote>
<p>看这三种的具体用法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Admin</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">privileges</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">startDate</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface ElevatedEmployee extends Employee, Admin &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElevatedEmployee</span> = <span class="title class_">Admin</span> &amp; <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">e1</span>: <span class="title class_">ElevatedEmployee</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>,</span><br><span class="line">  <span class="attr">privileges</span>: [<span class="string">&#x27;create-server&#x27;</span>],</span><br><span class="line">  <span class="attr">startDate</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Combinable</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Numeric</span> = <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Universal</span> = <span class="title class_">Combinable</span> &amp; <span class="title class_">Numeric</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnknownEmployee</span> = <span class="title class_">Employee</span> | <span class="title class_">Admin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + emp.<span class="property">name</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Privileges: &#x27;</span> + emp.<span class="property">privileges</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;startDate&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start Date: &#x27;</span> + emp.<span class="property">startDate</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printEmployeeInformation</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Manu&#x27;</span>, <span class="attr">startDate</span>: <span class="keyword">new</span> <span class="title class_">Date</span>() &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">drive</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Driving...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> &#123;</span><br><span class="line">  <span class="title function_">drive</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Driving a truck...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loadCargo</span>(<span class="params">amount: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Loading cargo ...&#x27;</span> + amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Vehicle</span> = <span class="title class_">Car</span> | <span class="title class_">Truck</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="keyword">new</span> <span class="title class_">Truck</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useVehicle</span>(<span class="params">vehicle: Vehicle</span>) &#123;</span><br><span class="line">  vehicle.<span class="title function_">drive</span>();</span><br><span class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> <span class="title class_">Truck</span>) &#123;</span><br><span class="line">    vehicle.<span class="title function_">loadCargo</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useVehicle</span>(v1);</span><br><span class="line"><span class="title function_">useVehicle</span>(v2);</span><br></pre></td></tr></table></figure>



<h2 id="Discriminated-Union"><a href="#Discriminated-Union" class="headerlink" title="Discriminated Union"></a>Discriminated Union</h2><blockquote>
<p>Discriminated 受歧视的，可辨别的， Discriminated Union 可辨识联合类型</p>
</blockquote>
<p>something that helps you with type guards</p>
<p>它的出现代表了三个：可辨识，联合类型，类型守卫</p>
<p>给需要辨别的类型不同的属性，自己起名字，一般是type</p>
<p>使用类型守卫思想的时候，可以通过type来判断这个属于哪一个类，然后分别进行对应的操作，通过switch(xxx) case ‘ xx’: xx break;</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;  </span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>;</span><br><span class="line">  <span class="attr">flyingSpeed</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;horse&#x27;</span>;</span><br><span class="line">  <span class="attr">runningSpeed</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = <span class="title class_">Bird</span> | <span class="title class_">Horse</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moveAnimal</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> speed;</span><br><span class="line">  <span class="keyword">switch</span> (animal.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;bird&#x27;</span>:</span><br><span class="line">      speed = animal.<span class="property">flyingSpeed</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;horse&#x27;</span>:</span><br><span class="line">      speed = animal.<span class="property">runningSpeed</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Moving at speed: &#x27;</span> + speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">moveAnimal</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;bird&#x27;</span>, <span class="attr">flyingSpeed</span>: <span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="Type-Casting"><a href="#Type-Casting" class="headerlink" title="Type Casting"></a>Type Casting</h2><blockquote>
<p>cast 铸造  type casting 类型转换，强制类型转换</p>
</blockquote>
<p>ts有时候识别不出来变量的具体类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInputElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-input&#x27;</span>);</span><br><span class="line">userInputElement.<span class="property">value</span>   <span class="comment">//fault</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，userInputElement可能是HTMLElement,但不一定有value,这时候要告诉ts这个元素是什么类型，保证有value元素</p>
<p>两种方法：</p>
<ul>
<li><p>在想要转换的前面加上 &lt;&gt; 标签<br>但是和react的jsx语法重了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">HTMLInputElement</span>&gt;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-input&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>as 然后后面加上变成什么类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInputElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userInputElement) &#123;</span><br><span class="line">  (userInputElement <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span> = <span class="string">&#x27;Hi there!&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Index-properties"><a href="#Index-properties" class="headerlink" title="Index properties"></a>Index properties</h2><p>接口里面如果不确定一个类里面有多少的属性，但是所有的属性的类型都是确定的，就可以用index properties</p>
<p><code>[prop:string]:string</code></p>
<p>代表所有的属性的名称都是string类型,而且这些属性的类型都是string类型</p>
<p>如果想要在接口里面添加一个确定的属性，这个属性只能和index properties的类型相同</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorContainer</span> &#123; <span class="comment">// &#123; email: &#x27;Not a valid email&#x27;, username: &#x27;Must start with a character!&#x27; &#125;</span></span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">   <span class="comment">// id:string  只能是string类型，要和[prop: string]的类型保持一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">errorBag</span>: <span class="title class_">ErrorContainer</span> = &#123;</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&#x27;Not a valid email!&#x27;</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;Must start with a capital character!&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Function-Overloads"><a href="#Function-Overloads" class="headerlink" title="Function Overloads"></a>Function Overloads</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当add输入的都是number的时候，返回值一定是number，这时候就可以用重载了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27; Schwarz&#x27;</span>); <span class="comment">//这个的返回值就确定是string了</span></span><br></pre></td></tr></table></figure>



<h2 id="Optional-Chaining-Nullish-Coalescing"><a href="#Optional-Chaining-Nullish-Coalescing" class="headerlink" title="Optional Chaining | Nullish Coalescing"></a>Optional Chaining | Nullish Coalescing</h2><p>可能会遇到向后端取数据的时候，没有这个参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myadmin?.<span class="property">startDate</span>?);</span><br></pre></td></tr></table></figure>

<p>在后面加上 ？ 来检测一下即可</p>
<p>Nullish Coalescing</p>
<blockquote>
<p>空值合并</p>
</blockquote>
<p>简单来说，在 <code>let x = foo ?? bar();</code> 中，如果 <code>foo</code> 为 <code>null</code> 或 <code>undefined</code> ,则 <code>x = bar()</code> , 否则 <code>x = foo</code> ;</p>
<p>和这个的作用一样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = (foo !== <span class="literal">null</span> &amp;&amp; foo !== <span class="literal">undefined</span>)</span><br><span class="line">    ? foo</span><br><span class="line">    : <span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个错误的实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = foo || <span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>

<p>如果foo是0或者“”（空的字符串）之类的被识别成false的，x也会变成bar,这里出现了错误</p>
</blockquote>
<h1 id="Generics-范型"><a href="#Generics-范型" class="headerlink" title="Generics(范型)"></a>Generics(范型)</h1><p>是ts自己的,js没有</p>
<p>自带的泛型类型</p>
<p>Array&lt; string &gt; 代表这个数组里面存的都是string类型</p>
<p>promise&lt; number &gt; 代表promise里面存的都是数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">names</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = []; <span class="comment">// string[]</span></span><br><span class="line">names[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);  <span class="comment">//不能用这个方法，因为上面Array里面存的是number类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">promise</span>: <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>);  <span class="comment">//resolve传入的值要和Promise&lt;string&gt;的string一致</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="Generic-Functions-amp-Classes"><a href="#Generic-Functions-amp-Classes" class="headerlink" title="Generic Functions &amp; Classes"></a>Generic Functions &amp; Classes</h2><h3 id="Generic-Function"><a href="#Generic-Function" class="headerlink" title="Generic Function"></a>Generic Function</h3><p>当不用泛型的时候:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">objA: <span class="built_in">object</span>, objB: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(objA, objB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mergedObj=<span class="title function_">merge</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;sun&#x27;</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mergedObj.<span class="property">name</span>);  <span class="comment">//这里读不到mergedObj,因为ts以为这是个object类型</span></span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> merge&lt;T, U&gt;(<span class="attr">objA</span>: T, <span class="attr">objB</span>: U) &#123; <span class="comment">//T和U代表这是任意的类型，不关心具体是什么类型，前面的&lt; T,U &gt;代表类型是这两个类型的结合</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(objA, objB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergedObj = <span class="title function_">merge</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="attr">hobbies</span>: [<span class="string">&#x27;Sports&#x27;</span>] &#125;, &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mergedObj.<span class="property">name</span>);  <span class="comment">//这个是可以的，ts能识别到</span></span><br></pre></td></tr></table></figure>

<h3 id="Generic-Classes"><a href="#Generic-Classes" class="headerlink" title="Generic Classes"></a>Generic Classes</h3><p>需要这个类有一定的方法，但不关心这个传入的类的类型具体是什么东西，就可以用泛型啦</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataStorage</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>&gt; &#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addItem</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeItem</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">indexOf</span>(item), <span class="number">1</span>); <span class="comment">// -1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>.<span class="property">data</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textStorage = <span class="keyword">new</span> <span class="title class_">DataStorage</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">textStorage.<span class="title function_">addItem</span>(<span class="string">&#x27;Max&#x27;</span>);</span><br><span class="line">textStorage.<span class="title function_">addItem</span>(<span class="string">&#x27;Manu&#x27;</span>);</span><br><span class="line">textStorage.<span class="title function_">removeItem</span>(<span class="string">&#x27;Max&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textStorage.<span class="title function_">getItems</span>());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>上面的removeItem的方法无法直接处理对象，</p>
<p>因为对象存的是一个指针，<code>this.data.indexOf(item)</code>找不到，只能返回-1,然后<code>this.data.splice(-1, 1)</code>就是把最后一个元素去除了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objStorage = <span class="keyword">new</span> <span class="title class_">DataStorage</span>&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">objStorage.<span class="title function_">addItem</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>&#125;);</span><br><span class="line">objStorage.<span class="title function_">addItem</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Manu&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">objStorage.<span class="title function_">removeItem</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>&#125;);  <span class="comment">//因为对象存的是一个指针，这里是在找指针，找不到具体的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objStorage.<span class="title function_">getItems</span>());</span><br></pre></td></tr></table></figure>

<p>所以在找的时候，要传入完全相同的对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objStorage = <span class="keyword">new</span> <span class="title class_">DataStorage</span>&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> maxObj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Max&#x27;</span>&#125;;</span><br><span class="line">objStorage.<span class="title function_">addItem</span>(maxObj);</span><br><span class="line">objStorage.<span class="title function_">addItem</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Manu&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">objStorage.<span class="title function_">removeItem</span>(maxObj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objStorage.<span class="title function_">getItems</span>());</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><blockquote>
<p>约束</p>
</blockquote>
<p>这里的objA,objB可以是任意的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> merge&lt;T, U&gt;(<span class="attr">objA</span>: T, <span class="attr">objB</span>: U)</span><br></pre></td></tr></table></figure>

<p>想要对T,U进行约束，使用extend关键字</p>
<p>下面是T和U都要是object类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> merge&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">objA</span>: T, <span class="attr">objB</span>: U)</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> merge&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">object</span>&gt;(<span class="attr">objA</span>: T, <span class="attr">objB</span>: U)</span><br></pre></td></tr></table></figure>



<p>用接口来限制length属性，传入函数的可以是任意的类，但是一定要有length属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthy</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> countAndDescribe&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthy</span>&gt;(<span class="attr">element</span>: T): [T, <span class="built_in">string</span>] &#123;  <span class="comment">//不关心传入的element有什么，但是一定要符合Lengthy</span></span><br><span class="line">  <span class="keyword">let</span> descriptionText = <span class="string">&#x27;Got no value.&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    descriptionText = <span class="string">&#x27;Got 1 element.&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    descriptionText = <span class="string">&#x27;Got &#x27;</span> + element.<span class="property">length</span> + <span class="string">&#x27; elements.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [element, descriptionText];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">countAndDescribe</span>([<span class="string">&#x27;Sports&#x27;</span>, <span class="string">&#x27;Cooking&#x27;</span>]));</span><br></pre></td></tr></table></figure>

<h4 id="The-keyof-Constraint"><a href="#The-keyof-Constraint" class="headerlink" title="The keyof Constraint"></a>The keyof Constraint</h4><p>在原声的js里面可以通过这个访问obj里面的key属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractAndConvert</span>(<span class="params">obj,key</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ts:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> extractAndConvert&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(  <span class="comment">//U必须是T中的一个属性</span></span><br><span class="line">  <span class="attr">obj</span>: T,</span><br><span class="line">  <span class="attr">key</span>: U</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Value: &#x27;</span> + obj[key];  <span class="comment">//这样ts才能确定key是obj里面的一个属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Special-TypeScript-Types"><a href="#Special-TypeScript-Types" class="headerlink" title="Special TypeScript Types"></a>Special TypeScript Types</h2><h3 id="Partial-Type"><a href="#Partial-Type" class="headerlink" title="Partial Type"></a>Partial Type</h3><blockquote>
<p>Partial 偏爱的，部分的    可选属性</p>
</blockquote>
<p><code>Partial&lt;类型&gt;  </code></p>
<p>表示这个类型里面的变量不是一定要有的，是可选的</p>
<p>这样可以随时添加符合要求的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CourseGoal</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">completeUntil</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCourseGoal</span>(<span class="params"></span></span><br><span class="line"><span class="params">  title: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  description: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  date: <span class="built_in">Date</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">CourseGoal</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">courseGoal</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">CourseGoal</span>&gt; = &#123;&#125;;</span><br><span class="line">  courseGoal.<span class="property">title</span> = title;</span><br><span class="line">  courseGoal.<span class="property">description</span> = description;  <span class="comment">//这样可以像js一样直接添加需要的属性</span></span><br><span class="line">  courseGoal.<span class="property">completeUntil</span> = date;</span><br><span class="line">  <span class="keyword">return</span> courseGoal <span class="keyword">as</span> <span class="title class_">CourseGoal</span>;  <span class="comment">//因为返回的时候要求是CourseGoal,所以需要声明类型到CourseGoal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Readonly-Type"><a href="#Readonly-Type" class="headerlink" title="Readonly Type"></a>Readonly Type</h3><p>禁止修改</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">names</span>: <span class="title class_">Readonly</span>&lt;<span class="built_in">string</span>[]&gt; = [<span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>这样，就不能对names这个string[]数组进行修改了</p>
<h1 id="Decorators-装饰器"><a href="#Decorators-装饰器" class="headerlink" title="Decorators(装饰器)"></a>Decorators(装饰器)</h1><p>在tsconfig.json里面确保这一句是开着的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式（Decorator Pattern）也称为装饰器模式，在不改变对象自身的基础上，动态增加额外的职责。属于结构型模式的一种。</p>
<p><strong>使用装饰者模式的优点：把对象核心职责和要装饰的功能分开了。</strong>非侵入式的行为修改。</p>
<p>举个例子来说，原本长相一般的女孩，借助美颜功能，也能拍出逆天的颜值。只要善于运用辅助的装饰功能，开启瘦脸，增大眼睛，来点磨皮后，咔嚓一拍，惊艳无比。</p>
<p>经过这一系列叠加的装饰，你还是你，长相不增不减，却能在镜头前增加了多重美。如果你愿意，还可以尝试不同的装饰风格，只要装饰功能做的好，你就能成为“百变星君”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 女孩子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">  <span class="title function_">faceValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我原本的脸&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThinFace</span>  &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">girl</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">girl</span> = girl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">faceValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">girl</span>.<span class="title function_">faceValue</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开启瘦脸&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingEyes</span>  &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">girl</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">girl</span> = girl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">faceValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">girl</span>.<span class="title function_">faceValue</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;增大眼睛&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">girl = <span class="keyword">new</span> <span class="title class_">ThinFace</span>(girl);</span><br><span class="line">girl = <span class="keyword">new</span> <span class="title class_">IncreasingEyes</span>(girl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闪瞎你的眼</span></span><br><span class="line">girl.<span class="title function_">faceValue</span>(); <span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>从代码的表现来看，将一个对象嵌入到另一个对象中，相当于通过一个对象对另一个对象进行包装，形成一条包装链。调用后，随着包装的链条传递给每一个对象，让每个对象都有处理的机会。</p>
<p>这种方式在增加删除装饰功能上都有极大的灵活性，假如你有勇气展示真实的脸，去掉瘦脸的包装即可，这对其他功能毫无影响；假如要增加磨皮，再来个功能类，继续装饰下去，对其他功能也无影响，可以并存运行。</p>
<p><img src="https://tu.sunning.fit/i/2022/06/06/629dc8c55e535.png" alt="image-20220606172834453"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>装饰器实际上就是一个函数，在使用时前面加上@符号，写在要装饰的声明之前，多个装饰器同时作用在一个声明时，可以写一行或换行写</p>
<p>多个装饰器组合在一起，在运行时注意调用顺序是从下至上依次调用，和书写的顺序相反</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Logger</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Logging...&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(constructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要改成Logger方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Logger</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">_:<span class="built_in">Function</span></span>)&#123;   <span class="comment">//</span></span><br><span class="line">        xxxxxxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Logger</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;Max&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Creating person object...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pers = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">//不用这句话，装饰器也一样工作，当找到constructor装饰器就开始工作了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pers);</span><br></pre></td></tr></table></figure>

<h2 id="Decorator-Factories（装饰器工厂）"><a href="#Decorator-Factories（装饰器工厂）" class="headerlink" title="Decorator Factories（装饰器工厂）"></a>Decorator Factories（装饰器工厂）</h2><p>有时候要给装饰器传递一些参数，这要借助装饰器工厂函数。装饰器工厂函数实际上就是一个高阶函数，在调用后返回一个函数，返回的函数作为装饰器函数。</p>
<p>在装饰器工厂调用的顺序是</p>
<p>按照下面debug.log的1,2,3,4的顺序执行，因为装饰器工厂本质是一个函数，这个函数是js运行的，按照正常顺序执行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thinFace</span>(<span class="params">value: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1-瘦脸工厂方法&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`4-我是瘦脸的装饰器，要瘦脸<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">IncreasingEyes</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2-增大眼睛工厂方法&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`3-我是增大眼睛的装饰器，要<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span>(<span class="string">&#x27;50%&#x27;</span>)</span><br><span class="line"><span class="meta">@IncreasingEyes</span>(<span class="string">&#x27;增大一倍&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过传入的值来更改DOM元素</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WithTemplate</span>(<span class="params">template: <span class="built_in">string</span>, hookId: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">any</span></span>) &#123;  <span class="comment">//通过constructor来操作被修饰了的元素</span></span><br><span class="line">    <span class="keyword">const</span> hookEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(hookId);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">    <span class="keyword">if</span> (hookEl) &#123;</span><br><span class="line">      hookEl.<span class="property">innerHTML</span> = template;</span><br><span class="line">      hookEl.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>)!.<span class="property">textContent</span> = p.<span class="property">name</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Logger(&#x27;LOGGING - PERSON&#x27;)</span></span><br><span class="line"><span class="meta">@WithTemplate</span>(<span class="string">&#x27;&lt;h1&gt;My Person Object&lt;/h1&gt;&#x27;</span>, <span class="string">&#x27;app&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;Max&#x27;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Creating person object...&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>angular有类似的更高级的实现</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> decorateClass&lt;T&gt;(<span class="attr">constructor</span>: T) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(constructor === A) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@decorateClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以看出类装饰器接收的参数<code>constructor === A.prototype.constructor</code>，即<code>constructor</code>为<code>class A</code>的构造函数。</p>
<p>如果类装饰器返回一个构造函数, 它会使用提供的构造函数来替换类之前的声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> decorateClass&lt;T <span class="keyword">extends</span> &#123; <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;&#125; &#125;&gt;(<span class="attr">constructor</span>: T)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">constructor</span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@decorateClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>)  <span class="comment">// 输出 B</span></span><br></pre></td></tr></table></figure>





<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classDecorator</span>(<span class="params">value: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收一个构造函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thinFace</span>(<span class="params">constructor</span>)&#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">thinFaceFeature</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;瘦脸功能&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span></span><br><span class="line"><span class="meta">@classDecorator</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">thinFaceFeature</span>(); <span class="comment">// &#x27;瘦脸功能&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="属性装饰器-Property-Decorato"><a href="#属性装饰器-Property-Decorato" class="headerlink" title="属性装饰器(Property Decorato)"></a>属性装饰器(Property Decorato)</h2><p>作用在类中定义的属性上，这些属性不是原型上的属性，而是通过类实例化得到的实例对象上的属性。</p>
<p>装饰器同样会接受两个参数，</p>
<ul>
<li><p>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</p>
</li>
<li><p>成员的名字</p>
</li>
</ul>
<p>没有属性描述对象，与TypeScript是如何初始化属性装饰器的有关。 目前没有办法在定义一个原型对象的成员时描述一个实例属性。</p>
<p>什么时候调用：</p>
<ul>
<li>当这个属性被js注册的时候就被调用了</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propertyDecorator</span>(<span class="params">value: <span class="built_in">string</span>, Girl</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">prototype, key</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收原型对象，装饰的属性名，属性描述符&#x27;</span>, <span class="title class_">Girl</span>.<span class="property"><span class="keyword">prototype</span></span> === prototype)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thinFace</span>(<span class="params">prototype, key</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(prototype, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">  <span class="meta">@thinFace</span></span><br><span class="line">  <span class="meta">@propertyDecorator</span>(<span class="string">&#x27;属性装饰器&#x27;</span>, <span class="title class_">Girl</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>



<h2 id="对象的属性描述符："><a href="#对象的属性描述符：" class="headerlink" title="对象的属性描述符："></a>对象的属性描述符：</h2><p>​	我们在给对象添加属性的时候, 第一反应就是通过<code>[key]: value</code> 添加属性, 但其实这个<code>value</code>只是这个key属性的其中一种<strong>特性</strong>, 而<strong>描述当前这个对象属性特性</strong>的设置 就是<code>属性描述符</code></p>
<blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="attr">configurable</span>: 是否可删除</span><br><span class="line"><span class="attr">enumerable</span>: 是否可枚举(遍历)</span><br><span class="line"><span class="attr">value</span>: 属性值</span><br><span class="line"><span class="attr">writable</span>: 是否可修改</span><br></pre></td></tr></table></figure>

<p>直接通过<code>Object.defineProperty</code>添加的属性，除了value其他的三个属性都是false</p>
<p>直接添加属性的对象描述符四个全都是true</p>
<p>​	<strong>访问器修饰符</strong></p>
<p>就是用getter和setter替换掉了原来的value和writable属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">a</span> = newValue;</span><br><span class="line"> &#125;,</span><br><span class="line"> enumerable : <span class="literal">true</span>,</span><br><span class="line"> configurable : <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">c</span>, <span class="variable language_">window</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="Accessor-Decorators"><a href="#Accessor-Decorators" class="headerlink" title="Accessor  Decorators"></a>Accessor  Decorators</h2><p> The accessor decorator is applied to the <em>Property Descriptor</em> for the accessor and can be used to observe, modify, or replace an accessor’s definitions.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Log2</span>(<span class="params">target:<span class="built_in">any</span>,name:<span class="built_in">string</span>,descriptor:PropertyDescriptor</span>)&#123;</span><br><span class="line">    <span class="comment">//原型对象，名称，属性描述符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Log3</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  name: <span class="built_in">string</span> | <span class="built_in">Symbol</span>,</span></span><br><span class="line"><span class="params">  descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Method decorator!&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Log2</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">price</span>(<span class="params">val: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_price</span> = val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid price - should be positive!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Log3</span></span><br><span class="line">  <span class="title function_">getPriceWithTax</span>(<span class="params"><span class="meta">@Log4</span> tax: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_price</span> * (<span class="number">1</span> + tax);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Parameter-Decorators"><a href="#Parameter-Decorators" class="headerlink" title="Parameter Decorators"></a>Parameter Decorators</h2><blockquote>
<p>Parameter 参数</p>
</blockquote>
<p>原型对象，名字，参数在传入的第几个位置</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Log4</span>(<span class="params">target: <span class="built_in">any</span>, name: <span class="built_in">string</span> | <span class="built_in">Symbol</span>, position: <span class="built_in">number</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPriceWithTax</span>(<span class="meta">@Log4</span> <span class="attr">tax</span>: <span class="built_in">number</span>) <span class="comment">//比如这个就一个参数，所以位置是0</span></span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Log4</span>(<span class="params">target: <span class="built_in">any</span>, name: <span class="built_in">string</span> | <span class="built_in">Symbol</span>, position: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Parameter decorator!&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPriceWithTax</span>(<span class="params"><span class="meta">@Log4</span> tax: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_price</span> * (<span class="number">1</span> + tax);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p><em>方法装饰器</em>声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 <em>属性描述符</em>上，可以用来<strong>监视，修改或者替换</strong>方法定义。 </p>
<p>作用在类的方法上，有静态方法和原型方法。</p>
<ul>
<li>作用在静态方法上，装饰器函数接收的是类构造函数；</li>
<li>作用在原型方法上，装饰器函数接收的是原型对象。</li>
</ul>
<p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em>。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">methodDecorator</span>(<span class="params">value: <span class="built_in">string</span>, Girl</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">prototype, key, descriptor</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收原型对象，装饰的属性名，属性描述符&#x27;</span>, <span class="title class_">Girl</span>.<span class="property"><span class="keyword">prototype</span></span> === prototype)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thinFace</span>(<span class="params">prototype, key, descriptor</span>)&#123;</span><br><span class="line">  <span class="comment">// 保留原来的方法逻辑</span></span><br><span class="line">  <span class="keyword">let</span> originalMethod = descriptor.<span class="property">value</span>;</span><br><span class="line">  <span class="comment">// 改写，增加逻辑，并执行原有逻辑</span></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    originalMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>);  <span class="comment">// 注意修改this的指向</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开启瘦脸模式&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@thinFace</span></span><br><span class="line">  <span class="meta">@methodDecorator</span>(<span class="string">&#x27;方法装饰器&#x27;</span>, <span class="title class_">Girl</span>)</span><br><span class="line">  <span class="title function_">faceValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是原本的面目&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">faceValue</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>装饰器接收三个参数：</p>
<p>原型对象，方法名，描述对象</p>
</blockquote>
<p>要增强功能，可以保留原来的函数，改写描述对象的value为另一函数</p>
<p>当使用g.faceValue()访问方法时，访问的就是描述对象value对应的值</p>
<p>在改写的函数中增加逻辑，并执行原来保留的原函数，注意函数要用call或apply将this指向原型对象</p>
<h2 id="when-do-decoratos-execute"><a href="#when-do-decoratos-execute" class="headerlink" title="when do decoratos execute"></a>when do decoratos execute</h2><p>在被定义的时候执行，不是被实例化的时候执行</p>
<p>（假如是类装饰器，就在类被定义的时候装饰器就执行了，实例化类的时候不会执行</p>
<h2 id="Decorator-Return-Types"><a href="#Decorator-Return-Types" class="headerlink" title="Decorator Return Types"></a>Decorator Return Types</h2><h3 id="Returning-and-changing-a-Class-in-a-Class-Decorators"><a href="#Returning-and-changing-a-Class-in-a-Class-Decorators" class="headerlink" title="Returning(and changing) a Class in a Class Decorators"></a>Returning(and changing) a Class in a Class Decorators</h3><p>没有用这种写法之前的写法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WithTemplate</span>(<span class="params">template: <span class="built_in">string</span>, hookId: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TEMPLATE FACTORY&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering template&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> hookEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(hookId);</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">    <span class="keyword">if</span> (hookEl) &#123;</span><br><span class="line">      hookEl.<span class="property">innerHTML</span> = template;</span><br><span class="line">      hookEl.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>)!.<span class="property">textContent</span> = p.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WithTemplate</span>(<span class="params">template: <span class="built_in">string</span>, hookId: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TEMPLATE FACTORY&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>&lt;T <span class="keyword">extends</span> &#123; <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]): &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125; &#125;&gt;( </span><br><span class="line">    <span class="attr">originalConstructor</span>: T</span><br><span class="line">  ) &#123;  <span class="comment">//function&lt;T extends &#123; new (...args: any[]): &#123;name: string&#125; &#125;&gt; 这一整个是一个泛型，代表的是一个构造器：&#123; new (...args: any[]): &#123;name: string&#125; &#125; 是一个对象，里面有new 方法，方法可以接受任意的参数，另外其中一定会返回一个对象，属性是name（因为后面this.name用的上，需要告诉ts用的上）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> originalConstructor &#123; <span class="comment">//在这里可以写一个新的构造器用来代替旧的那个，这里写class是想要构造器写class是个语法糖，class后面不用写具体的名称，这里新写的类要继承自原来的构造函数</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">..._: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();  <span class="comment">//因为继承要有super</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering template&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> hookEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(hookId);</span><br><span class="line">        <span class="keyword">if</span> (hookEl) &#123;</span><br><span class="line">          hookEl.<span class="property">innerHTML</span> = template; </span><br><span class="line">          hookEl.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>)!.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">name</span>;  <span class="comment">//不用像上面一样实例化了，直接用this.就能获得了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="other-decorator-return-types"><a href="#other-decorator-return-types" class="headerlink" title="other decorator return types"></a>other decorator return types</h3><p>属性或者参数的修饰器的返回值不会被使用</p>
<h2 id="Example-Creating-an-Autobind-Decorator"><a href="#Example-Creating-an-Autobind-Decorator" class="headerlink" title="Example Creating an Autobind Decorator"></a>Example Creating an Autobind Decorator</h2><p>js关于this的指向的一个坑</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&#123;</span><br><span class="line">    message=<span class="string">&#x27;this works!&#x27;</span>;</span><br><span class="line">    <span class="title function_">showMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line"><span class="keyword">const</span> button=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)!;</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,p.<span class="property">showMessage</span>.<span class="title function_">bind</span>(p));<span class="comment">//如果去掉bind这个属性，那么执行this.message的时候this指的是addEventListener这个绑定了的东西，而不是Printer里面的mess</span></span><br></pre></td></tr></table></figure>

<p>为了实现自动绑定，可以用一个方法装饰器</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Autobind</span>(<span class="params">_: <span class="built_in">any</span>, _2: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> originalMethod = descriptor.<span class="property">value</span>;  <span class="comment">//这是获取方法原来的操作</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">adjDescriptor</span>: <span class="title class_">PropertyDescriptor</span> = &#123;  <span class="comment">//返回一个新的descriptor（ 即改写原来被装饰的方法</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> boundFn = originalMethod.<span class="title function_">bind</span>(<span class="variable language_">this</span>);  <span class="comment">//这里相当于改写了被装饰的方法</span></span><br><span class="line">      <span class="keyword">return</span> boundFn;  <span class="comment">//改写了get属性，记得return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> adjDescriptor;  <span class="comment">//把改写了的方法返回回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Decorators-for-Validation"><a href="#Decorators-for-Validation" class="headerlink" title="Decorators for Validation"></a>Decorators for Validation</h2><blockquote>
<p>Validation 生效；批准；验证；确认；证实；核实</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ValidatorConfig</span> &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">string</span>]: &#123;</span><br><span class="line">    [<span class="attr">validatableProp</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>[]; <span class="comment">// [&#x27;required&#x27;, &#x27;positive&#x27;]</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是任意属性里面又包了一层任意属性</p>
<h1 id="Namespaces-amp-Modules"><a href="#Namespaces-amp-Modules" class="headerlink" title="Namespaces&amp;Modules"></a>Namespaces&amp;Modules</h1><blockquote>
<p>syntax 语法</p>
</blockquote>
<table>
<thead>
<tr>
<th>Namespace &amp; File Bunding</th>
<th align="left">ES6 Imports&#x2F;Exports</th>
</tr>
</thead>
<tbody><tr>
<td>Use “namespace” code syntax to group code</td>
<td align="left">Use ES6 import&#x2F;export syntax</td>
</tr>
<tr>
<td>Per-file or bundled compilation is possible</td>
<td align="left">Per-file compilation but single &lt; script &gt; import</td>
</tr>
</tbody></table>
<p>命名空间可以放所有的东西</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Draggable</span> &#123;  <span class="comment">//这个接口没有暴露，只能在这个命名空间里面使用</span></span><br><span class="line">    <span class="title function_">dragStartHandler</span>(<span class="attr">event</span>: <span class="title class_">DragEvent</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">dragEndHandler</span>(<span class="attr">event</span>: <span class="title class_">DragEvent</span>): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">DragTarget</span> &#123;  <span class="comment">//这个接口已经暴露在外面了，在不在命名空间里面都可以使用</span></span><br><span class="line">    <span class="title function_">dragOverHandler</span>(<span class="attr">event</span>: <span class="title class_">DragEvent</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">dropHandler</span>(<span class="attr">event</span>: <span class="title class_">DragEvent</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">dragLeaveHandler</span>(<span class="attr">event</span>: <span class="title class_">DragEvent</span>): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x2F;&#x2F;&#x2F; 是ts的语法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt; reference path=&quot;drag-drop-interfaces.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure>



<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做<code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。 相反的，变量 <code>lettersRegexp</code>和<code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="命名空间里东西的访问"><a href="#命名空间里东西的访问" class="headerlink" title="命名空间里东西的访问:"></a>命名空间里东西的访问:</h3><p> 命名空间.xxxx</p>
<p><strong>别名：</strong></p>
<p>使用import q&#x3D;x.y.z给常用的对象起一个短的名字，不要与用来加载模块的 <code>import x = require(&#39;name&#39;)</code>语法弄混了，这里的语法是为指定的符号创建一个别名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>(); <span class="comment">// Same as &quot;new Shapes.Polygons.Square()&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="多文件中的命名空间"><a href="#多文件中的命名空间" class="headerlink" title="多文件中的命名空间"></a>多文件中的命名空间</h3><p>在不同的文件里面用同一个namespace就和是在同一个文件里面写的命名空间一样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">        <span class="title function_">isAcceptable</span>(<span class="attr">s</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Validation</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LettersOnlyValidator</span> <span class="keyword">implements</span> <span class="title class_">StringValidator</span> &#123;</span><br><span class="line">        <span class="title function_">isAcceptable</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.<span class="title function_">test</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</span><br><span class="line"></span><br><span class="line">第一种方式，把所有的输入文件编译为一个输出文件，需要使用--outFile标记：</span><br><span class="line"></span><br><span class="line">tsc --outFile sample.js Test.ts</span><br><span class="line">编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</span><br><span class="line"></span><br><span class="line">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</span><br><span class="line">第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 &lt;script&gt;标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</span><br><span class="line"></span><br><span class="line">MyTestPage.html (excerpt)</span><br><span class="line">    &lt;script src=<span class="string">&quot;Validation.js&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;LettersOnlyValidator.js&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;ZipCodeValidator.js&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;Test.js&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用<code>export</code>形式之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <code>import</code>形式之一。</p>
<h2 id="命名空间和模块的陷阱"><a href="#命名空间和模块的陷阱" class="headerlink" title="命名空间和模块的陷阱"></a>命名空间和模块的陷阱</h2><h3 id="对模块使用-lt-reference-gt"><a href="#对模块使用-lt-reference-gt" class="headerlink" title="对模块使用/// &lt;reference&gt;"></a>对模块使用<code>/// &lt;reference&gt;</code></h3><p>一个常见的错误是使用<code>/// &lt;reference&gt;</code>引用模块文件，应该使用<code>import</code></p>
<h3 id="不必要的命名空间"><a href="#不必要的命名空间" class="headerlink" title="不必要的命名空间"></a>不必要的命名空间</h3><p>如果你想把命名空间转换为模块，它可能会像下面这个文件一件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该改成:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Sun wen xiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/21/TypeScript/">http://example.com/2022/07/21/TypeScript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">孙文祥的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="https://tu.sunning.fit/i/y/47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/21/Vuetify/"><img class="prev-cover" src="https://tu.sunning.fit/i/y/102.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vuetify</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/21/Vs%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88ride%E4%B9%9F%E9%80%82%E7%94%A8%EF%BC%89/"><img class="next-cover" src="https://tu.sunning.fit/i/y/45.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vs快捷键（ride也适用）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/21/Axios/" title="Axios"><img class="cover" src="https://tu.sunning.fit/i/y/119.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">Axios</div></div></a></div><div><a href="/2022/07/21/BOM/" title="BOM"><img class="cover" src="https://tu.sunning.fit/i/y/70.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">BOM</div></div></a></div><div><a href="/2022/07/21/Echarts%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" title="Echarts数据可视化"><img class="cover" src="https://tu.sunning.fit/i/y/20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">Echarts数据可视化</div></div></a></div><div><a href="/2022/07/21/JavaScript%E5%9F%BA%E7%A1%80/" title="JavaScript基础"><img class="cover" src="https://tu.sunning.fit/i/y/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">JavaScript基础</div></div></a></div><div><a href="/2022/07/21/Mock/" title="Mock"><img class="cover" src="https://tu.sunning.fit/i/y/67.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">Mock</div></div></a></div><div><a href="/2022/07/21/Pinia/" title="Pinia"><img class="cover" src="https://tu.sunning.fit/i/y/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">Pinia</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sun wen xiang</div><div class="author-info__description">遇到困难睡大觉</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sunwenxiang133"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">安装和介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Core-Types"><span class="toc-number">2.</span> <span class="toc-text">Core Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#number-string-boolean"><span class="toc-number">2.1.</span> <span class="toc-text">number,string,boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boject"><span class="toc-number">2.2.</span> <span class="toc-text">boject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">2.3.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple%EF%BC%88%E5%85%83%E7%BB%84%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">Tuple（元组）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum"><span class="toc-number">2.5.</span> <span class="toc-text">Enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-number">2.6.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Union-Types"><span class="toc-number">2.7.</span> <span class="toc-text">Union Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Literal-Type"><span class="toc-number">2.8.</span> <span class="toc-text">Literal Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Aliases-aliases-custom-types%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">Type Aliases | aliases custom types（自定义类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-Return-Types-amp-void"><span class="toc-number">2.10.</span> <span class="toc-text">Function Return Types &amp; void</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-as-types"><span class="toc-number">3.</span> <span class="toc-text">Function as types</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-as-types-amp-Callback-%E5%9B%9E%E8%B0%83"><span class="toc-number">4.</span> <span class="toc-text">Function as types&amp;Callback(回调)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unknown-type"><span class="toc-number">5.</span> <span class="toc-text">unknown type</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#never-type"><span class="toc-number">5.1.</span> <span class="toc-text">never type</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">任意属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">string类型任意属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#number%E7%B1%BB%E5%9E%8B%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">number类型任意属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E4%B8%A4%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">同时定义两种属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">同时定义任意属性和其他类型的属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Compiler-amp-Configuration-Deep-Dive"><span class="toc-number">7.</span> <span class="toc-text">Compiler&amp;Configuration Deep Dive</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AElive-server"><span class="toc-number">7.1.</span> <span class="toc-text">手动配置live-server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch-model-amp-tsc-%E5%85%A8%E5%B1%80"><span class="toc-number">7.2.</span> <span class="toc-text">watch model &amp; tsc 全局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tsconfig-json"><span class="toc-number">7.3.</span> <span class="toc-text">tsconfig.json</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exclude%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">exclude配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#include%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.2.</span> <span class="toc-text">include配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#files%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.3.</span> <span class="toc-text">files配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Anvance-JavaScript"><span class="toc-number">8.</span> <span class="toc-text">Anvance JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84%E5%87%BD%E6%95%B0%E5%80%BC"><span class="toc-number">8.1.</span> <span class="toc-text">设置默认的函数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-x3D-%E5%AF%B9%E8%B1%A1-vs-%E5%AF%B9%E8%B1%A1-x3D-%E2%80%A6%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.2.</span> <span class="toc-text">对象&#x3D;对象 vs 对象&#x3D;{…对象}</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rest-Parameters"><span class="toc-number">8.3.</span> <span class="toc-text">Rest Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-amp-Object-Destructuring"><span class="toc-number">8.4.</span> <span class="toc-text">Array &amp; Object Destructuring</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-amp-Interfaces"><span class="toc-number">9.</span> <span class="toc-text">Class &amp; Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">9.1.</span> <span class="toc-text">Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance-%E7%BB%A7%E6%89%BF"><span class="toc-number">9.2.</span> <span class="toc-text">Inheritance (继承)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="toc-number">9.2.1.</span> <span class="toc-text">对继承的对象扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getters-amp-Setters"><span class="toc-number">9.3.</span> <span class="toc-text">Getters &amp; Setters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-properties-and-methods"><span class="toc-number">9.4.</span> <span class="toc-text">Static properties and methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Override-and-Abstract"><span class="toc-number">9.5.</span> <span class="toc-text">Override and Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Singleton-Pattern"><span class="toc-number">9.6.</span> <span class="toc-text">Singleton Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface"><span class="toc-number">9.7.</span> <span class="toc-text">Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">9.7.1.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%AE%9A"><span class="toc-number">9.7.2.</span> <span class="toc-text">规定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-Types-amp-TypeScript-Features"><span class="toc-number">9.8.</span> <span class="toc-text">Advanced Types &amp; TypeScript Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intersection-Types"><span class="toc-number">9.8.1.</span> <span class="toc-text">Intersection Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Guards"><span class="toc-number">9.9.</span> <span class="toc-text">Type Guards</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Discriminated-Union"><span class="toc-number">9.10.</span> <span class="toc-text">Discriminated Union</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Casting"><span class="toc-number">9.11.</span> <span class="toc-text">Type Casting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Index-properties"><span class="toc-number">9.12.</span> <span class="toc-text">Index properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-Overloads"><span class="toc-number">9.13.</span> <span class="toc-text">Function Overloads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optional-Chaining-Nullish-Coalescing"><span class="toc-number">9.14.</span> <span class="toc-text">Optional Chaining | Nullish Coalescing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generics-%E8%8C%83%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">Generics(范型)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Generic-Functions-amp-Classes"><span class="toc-number">10.1.</span> <span class="toc-text">Generic Functions &amp; Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Function"><span class="toc-number">10.1.1.</span> <span class="toc-text">Generic Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Classes"><span class="toc-number">10.1.2.</span> <span class="toc-text">Generic Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constraints"><span class="toc-number">10.2.</span> <span class="toc-text">Constraints</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-keyof-Constraint"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">The keyof Constraint</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Special-TypeScript-Types"><span class="toc-number">10.3.</span> <span class="toc-text">Special TypeScript Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Type"><span class="toc-number">10.3.1.</span> <span class="toc-text">Partial Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Readonly-Type"><span class="toc-number">10.3.2.</span> <span class="toc-text">Readonly Type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Decorators-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">Decorators(装饰器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decorator-Factories%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B7%A5%E5%8E%82%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">Decorator Factories（装饰器工厂）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">11.4.</span> <span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8-Property-Decorato"><span class="toc-number">11.5.</span> <span class="toc-text">属性装饰器(Property Decorato)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">11.6.</span> <span class="toc-text">对象的属性描述符：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accessor-Decorators"><span class="toc-number">11.7.</span> <span class="toc-text">Accessor  Decorators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parameter-Decorators"><span class="toc-number">11.8.</span> <span class="toc-text">Parameter Decorators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">11.9.</span> <span class="toc-text">方法装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when-do-decoratos-execute"><span class="toc-number">11.10.</span> <span class="toc-text">when do decoratos execute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decorator-Return-Types"><span class="toc-number">11.11.</span> <span class="toc-text">Decorator Return Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Returning-and-changing-a-Class-in-a-Class-Decorators"><span class="toc-number">11.11.1.</span> <span class="toc-text">Returning(and changing) a Class in a Class Decorators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other-decorator-return-types"><span class="toc-number">11.11.2.</span> <span class="toc-text">other decorator return types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Example-Creating-an-Autobind-Decorator"><span class="toc-number">11.12.</span> <span class="toc-text">Example Creating an Autobind Decorator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decorators-for-Validation"><span class="toc-number">11.13.</span> <span class="toc-text">Decorators for Validation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Namespaces-amp-Modules"><span class="toc-number">12.</span> <span class="toc-text">Namespaces&amp;Modules</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.1.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%87%8C%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">12.1.1.</span> <span class="toc-text">命名空间里东西的访问:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.1.2.</span> <span class="toc-text">多文件中的命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">12.2.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">12.3.</span> <span class="toc-text">命名空间和模块的陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8-lt-reference-gt"><span class="toc-number">12.3.1.</span> <span class="toc-text">对模块使用&#x2F;&#x2F;&#x2F; &lt;reference&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.3.2.</span> <span class="toc-text">不必要的命名空间</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/Axios/" title="Axios"><img src="https://tu.sunning.fit/i/y/119.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Axios"/></a><div class="content"><a class="title" href="/2022/07/21/Axios/" title="Axios">Axios</a><time datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/BFS/" title="BFS"><img src="https://tu.sunning.fit/i/y/46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BFS"/></a><div class="content"><a class="title" href="/2022/07/21/BFS/" title="BFS">BFS</a><time datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/BOM/" title="BOM"><img src="https://tu.sunning.fit/i/y/70.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BOM"/></a><div class="content"><a class="title" href="/2022/07/21/BOM/" title="BOM">BOM</a><time datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/Clion%E4%BD%BF%E7%94%A8/" title="Clion使用"><img src="https://tu.sunning.fit/i/y/18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Clion使用"/></a><div class="content"><a class="title" href="/2022/07/21/Clion%E4%BD%BF%E7%94%A8/" title="Clion使用">Clion使用</a><time datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/DFS/" title="DFS"><img src="https://tu.sunning.fit/i/y/88.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DFS"/></a><div class="content"><a class="title" href="/2022/07/21/DFS/" title="DFS">DFS</a><time datetime="2022-07-21T00:43:02.000Z" title="发表于 2022-07-21 08:43:02">2022-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Sun wen xiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>